1：策略模式
   1模拟鸭子项目
   2项目的新需求
   3用oo解决新需求的不足
   4用策略模式解决新的需求
   5重新设计模拟鸭子项目
   6总结策略模式定义

2：抽象类
    1.不能实例化    成员变量、成员方法和构造方法的访问方式和普通类一样
    2：由于不能实例化所以需要继承才能被使用
    3：一个类只能继承一个抽象类，而一个类却可以实现多个接口。


 3：当写完绿头鸭和红头鸭的时候出现新需求 看看这个设计的扩展性
        需求1设计一个会飞的鸭子
         设计思想
          1）：在超类Duck中添加一个public void absolute fly()方法  -----超类添加会影响所有子类
           这样的缺陷   当遇到大雁之类的放在超类可以，大雁会飞，但不是所有鸭子都会飞 ，如果家鸭就不会 ，所以放在超类会形成默认所有鸭子会飞

         2）设计思路：在绿头鸭中添加方法public void  fly(){}用来覆盖子类的fly方法
           思路缺陷：当设计好了几十种鸭子，然后添加了新需求要把这十几中鸭子中添加覆盖。工作量较大

         需求2：设计一个石头鸭子：该鸭子不会叫，也不会游泳
               此时需要覆盖掉超类的叫  和游泳方法

         3）用策略模式设计    新设计的鸭子类      NewDuck
             分析出项目中变化与不变化的部分，提取变化部分，抽象成接口+实现
             如：鸭子有哪些功能会根据需求变化？  如：叫声  飞行
             飞行的。接口：飞行接口
             public interface FlyBehavior{
                 void fly();
             }

             叫声接口：
               public interface SpeakBehavior{
                               void speak();
                           }


         所以一般讲行为变为接口来实现

         4）策略模式分别封装行为接口，实现算法族，超类里面存放行为接口对象在子类里面实现具体对象